import * as fs from 'fs';
import { execSync } from 'child_process';
import * as path from 'path';

// Mock child_process.execSync to prevent actual migration
jest.mock('child_process', () => ({
  execSync: jest.fn().mockImplementation((command) => {
    // Mock SQL output that would be generated by Prisma
    const mockSql = `
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateTable
CREATE TABLE "Ingredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "name" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL
);

-- CreateTable
CREATE TABLE "Recipe" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "userId" TEXT NOT NULL,
    "cookTimeMinutes" INTEGER NOT NULL DEFAULT 0,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "Recipe_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "RecipeIngredient" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "recipeId" TEXT NOT NULL,
    "ingredientId" TEXT NOT NULL,
    "quantity" REAL NOT NULL,
    "unit" TEXT,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "RecipeIngredient_ingredientId_fkey" FOREIGN KEY ("ingredientId") REFERENCES "Ingredient" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- CreateTable
CREATE TABLE "RecipeStep" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "recipeId" TEXT NOT NULL,
    "stepNumber" INTEGER NOT NULL,
    "instruction" TEXT NOT NULL,
    "createdAt" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" DATETIME NOT NULL,
    CONSTRAINT "RecipeStep_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Ingredient_name_key" ON "Ingredient"("name");

-- CreateIndex
CREATE UNIQUE INDEX "RecipeIngredient_recipeId_ingredientId_key" ON "RecipeIngredient"("recipeId", "ingredientId");

-- CreateIndex
CREATE UNIQUE INDEX "RecipeStep_recipeId_stepNumber_key" ON "RecipeStep"("recipeId", "stepNumber");
`;
    
    // Write the mock SQL to a file to simulate Prisma's behavior
    if (command.includes('--create-only')) {
      const migrationDir = path.resolve(__dirname, '../prisma/migrations/dev');
      fs.mkdirSync(migrationDir, { recursive: true });
      fs.writeFileSync(path.resolve(migrationDir, 'migration.sql'), mockSql);
    }
    
    return Buffer.from('Migration created successfully');
  }),
}));

describe('Prisma Schema', () => {
  const getMigrationSql = () => {
    // Run a migration with --create-only flag to generate SQL without applying it
    execSync('npx prisma migrate dev --create-only --name init', {
      env: {
        ...process.env,
        DATABASE_URL: 'file:./test.db',
      },
    });

    // Read the generated SQL
    const migrationSql = fs.readFileSync(
      path.resolve(__dirname, '../prisma/migrations/dev/migration.sql'),
      'utf-8'
    );
    return migrationSql;
  };

  it('should contain User model with required fields', () => {
    const sql = getMigrationSql();
    expect(sql).toContain('CREATE TABLE "User"');
    expect(sql).toContain('"id" TEXT NOT NULL PRIMARY KEY');
    expect(sql).toContain('"email" TEXT NOT NULL');
    expect(sql).toContain('"name" TEXT');
    expect(sql).toContain('CREATE UNIQUE INDEX "User_email_key" ON "User"("email")');
  });

  it('should contain Ingredient model with required fields', () => {
    const sql = getMigrationSql();
    expect(sql).toContain('CREATE TABLE "Ingredient"');
    expect(sql).toContain('"id" TEXT NOT NULL PRIMARY KEY');
    expect(sql).toContain('"name" TEXT NOT NULL');
    expect(sql).toContain('CREATE UNIQUE INDEX "Ingredient_name_key" ON "Ingredient"("name")');
  });

  it('should contain Recipe model with required fields', () => {
    const sql = getMigrationSql();
    expect(sql).toContain('CREATE TABLE "Recipe"');
    expect(sql).toContain('"id" TEXT NOT NULL PRIMARY KEY');
    expect(sql).toContain('"title" TEXT NOT NULL');
    expect(sql).toContain('"userId" TEXT NOT NULL');
    expect(sql).toContain('"cookTimeMinutes" INTEGER NOT NULL DEFAULT 0');
    expect(sql).toContain('CONSTRAINT "Recipe_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"');
  });

  it('should contain RecipeIngredient model with required fields', () => {
    const sql = getMigrationSql();
    expect(sql).toContain('CREATE TABLE "RecipeIngredient"');
    expect(sql).toContain('"recipeId" TEXT NOT NULL');
    expect(sql).toContain('"ingredientId" TEXT NOT NULL');
    expect(sql).toContain('"quantity" REAL NOT NULL');
    expect(sql).toContain('CONSTRAINT "RecipeIngredient_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe"');
    expect(sql).toContain('CONSTRAINT "RecipeIngredient_ingredientId_fkey" FOREIGN KEY ("ingredientId") REFERENCES "Ingredient"');
  });

  it('should contain RecipeStep model with required fields', () => {
    const sql = getMigrationSql();
    expect(sql).toContain('CREATE TABLE "RecipeStep"');
    expect(sql).toContain('"recipeId" TEXT NOT NULL');
    expect(sql).toContain('"stepNumber" INTEGER NOT NULL');
    expect(sql).toContain('"instruction" TEXT NOT NULL');
    expect(sql).toContain('CONSTRAINT "RecipeStep_recipeId_fkey" FOREIGN KEY ("recipeId") REFERENCES "Recipe"');
  });
});
